mod http;
mod incident;
mod integrity;
mod metrics;
mod state;
mod static_ui;
mod tui;

use anyhow::Context;
use blackbox_core::checksum::verify_checksum;
use blackbox_core::orderbook::Orderbook;
use blackbox_core::recorder::Recorder;
use blackbox_core::replayer::Replayer;
use blackbox_core::incident::IncidentReason;
use blackbox_core::types::{FaultRule, FaultType, ReplayConfig, ReplayMode};
use blackbox_ws::client::{WsClient, WsEvent};
use clap::{Parser, Subcommand};
use http::router;
use incident::IncidentManager;
use metrics::init_metrics;
use state::AppState;
use std::path::PathBuf;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::mpsc;
use tokio::time::sleep;
use tracing::{error, info, warn};
use axum::response::Html;
use axum::routing::get;

#[derive(Parser)]
#[command(name = "blackbox")]
#[command(about = "Kraken WebSocket v2 market data client with orderbook engine and checksum verification")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Run the blackbox client
    Run {
        /// Symbols to subscribe to (comma-separated)
        #[arg(long, value_delimiter = ',')]
        symbols: Vec<String>,
        /// Orderbook depth
        #[arg(long, default_value = "100")]
        depth: u32,
        /// HTTP server address
        #[arg(long, default_value = "127.0.0.1:8080")]
        http: String,
        /// Ping interval (e.g., "30s")
        #[arg(long, default_value = "30s")]
        ping_interval: String,
        /// Recording file path (optional)
        #[arg(long)]
        record: Option<PathBuf>,
    },
    /// Replay a recording
    Replay {
        /// Input recording file
        #[arg(long)]
        input: PathBuf,
        /// Replay speed multiplier
        #[arg(long, default_value = "1.0")]
        speed: f64,
        /// HTTP server address
        #[arg(long, default_value = "127.0.0.1:8080")]
        http: String,
        /// Fault injection: drop every N updates
        #[arg(long)]
        fault_drop_every: Option<usize>,
        /// Fault injection: drop once at frame index
        #[arg(long)]
        fault_drop_once: Option<usize>,
        /// Fault injection: reorder once at frame index
        #[arg(long)]
        fault_reorder_once: Option<usize>,
        /// Fault injection: mutate qty once at frame index
        #[arg(long)]
        fault_mutate_once: Option<usize>,
        /// Delta ticks for qty mutation
        #[arg(long, default_value = "1")]
        fault_mutate_delta: i32,
    },
    /// Run with TUI (Integrity Console)
    Tui {
        /// Symbols to subscribe to (comma-separated)
        #[arg(long, value_delimiter = ',')]
        symbols: Vec<String>,
        /// Orderbook depth
        #[arg(long, default_value = "25")]
        depth: u32,
        /// HTTP server address
        #[arg(long, default_value = "127.0.0.1:8080")]
        http: String,
        /// Ping interval (e.g., "30s")
        #[arg(long, default_value = "30s")]
        ping_interval: String,
        /// Recording file path (optional)
        #[arg(long)]
        record: Option<PathBuf>,
        /// Replay recording file
        #[arg(long)]
        replay: Option<PathBuf>,
        /// Replay speed multiplier
        #[arg(long, default_value = "1.0")]
        speed: f64,
        /// Fault injection: none, drop, reorder, mutate_qty
        #[arg(long, default_value = "none")]
        fault: String,
        /// Fault injection: once at frame index
        #[arg(long)]
        once_at: Option<usize>,
        /// Mock mode (no real connection)
        #[arg(long)]
        mock: bool,
    },
    /// Replay an incident bundle
    ReplayIncident {
        /// Incident bundle ZIP file
        #[arg(long)]
        bundle: PathBuf,
        /// Replay speed multiplier
        #[arg(long, default_value = "4.0")]
        speed: f64,
        /// HTTP server address
        #[arg(long, default_value = "127.0.0.1:8080")]
        http: String,
    },
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .init();

    let cli = Cli::parse();

    match cli.command {
        Commands::Run {
            symbols,
            depth,
            http,
            ping_interval,
            record,
        } => {
            run_client(symbols, depth, http, ping_interval, record).await?;
        }
        Commands::Replay {
            input,
            speed,
            http,
            fault_drop_every,
            fault_drop_once,
            fault_reorder_once,
            fault_mutate_once,
            fault_mutate_delta,
        } => {
            let fault = build_fault_rule(
                fault_drop_every,
                fault_drop_once,
                fault_reorder_once,
                fault_mutate_once,
                fault_mutate_delta,
            );
            replay_recording(input, speed, http, fault).await?;
        }
        Commands::Tui {
            symbols,
            depth,
            http,
            ping_interval,
            record,
            replay,
            speed,
            fault,
            once_at,
            mock,
        } => {
            run_tui_mode(symbols, depth, http, ping_interval, record, replay, speed, fault, once_at, mock).await?;
        }
        Commands::ReplayIncident { bundle, speed, http } => {
            replay_incident_bundle(bundle, speed, http).await?;
        }
    }

    Ok(())
}

async fn run_client(
    symbols: Vec<String>,
    depth: u32,
    http_addr: String,
    ping_interval_str: String,
    record_path: Option<PathBuf>,
) -> anyhow::Result<()> {
    info!("Starting Kraken Blackbox");
    info!("Symbols: {:?}, Depth: {}, HTTP: {}", symbols, depth, http_addr);

    // Parse ping interval
    let ping_interval = parse_duration(&ping_interval_str)
        .context("Invalid ping interval format (e.g., '30s', '1m')")?;

    // Initialize metrics
    init_metrics();
    let _metrics_handle = metrics_exporter_prometheus::PrometheusBuilder::new()
        .install()
        .context("Failed to install Prometheus metrics exporter")?;

    // Create shared state
    let state = AppState::new();
    
    // Set depth for all symbols
    for symbol in &symbols {
        state.set_depth(symbol, depth);
    }

    // Create incident manager
    let incidents_dir = PathBuf::from("./incidents");
    let incident_manager = Arc::new(IncidentManager::new(incidents_dir)?);

    // Create recorder if needed
    let recorder = if let Some(path) = record_path {
        Some(Recorder::new(path)?)
    } else {
        None
    };

    // Create WebSocket event channel
    let (ws_tx, mut ws_rx) = mpsc::unbounded_channel();

    // Spawn WebSocket client
    let client = WsClient::new(symbols.clone(), depth, ping_interval, ws_tx);
    let client_handle = tokio::spawn(async move {
        if let Err(e) = client.run().await {
            error!("WebSocket client error: {}", e);
        }
    });

    // Spawn orderbook processor
    let state_clone = state.clone();
    let incident_manager_clone = incident_manager.clone();
    let mut recorder_mut = recorder;
    let processor_handle = tokio::spawn(async move {
        process_ws_events(&state_clone, &incident_manager_clone, &mut ws_rx, recorder_mut.as_mut()).await;
    });

    // Start HTTP server
    let app = router(state.clone(), incident_manager.clone())
        .route("/", get(|| async { Html(static_ui::UI_HTML) }));
    
    let server_handle = tokio::spawn(async move {
        let listener = tokio::net::TcpListener::bind(&http_addr).await.unwrap();
        info!("HTTP server listening on http://{}", http_addr);
        axum::serve(listener, app).await.unwrap();
    });

    // Wait for all tasks
    tokio::select! {
        _ = client_handle => {
            warn!("WebSocket client task ended");
        }
        _ = processor_handle => {
            warn!("Processor task ended");
        }
        _ = server_handle => {
            warn!("HTTP server task ended");
        }
    }

    Ok(())
}

async fn process_ws_events(
    state: &AppState,
    incident_manager: &Arc<IncidentManager>,
    ws_rx: &mut mpsc::UnboundedReceiver<WsEvent>,
    mut recorder: Option<&mut Recorder>,
) {
    while let Some(event) = ws_rx.recv().await {
        match event {
            WsEvent::Connected => {
                info!("WebSocket connected");
            }
            WsEvent::Disconnected => {
                warn!("WebSocket disconnected");
            }
            WsEvent::Frame(raw_frame) => {
                // Record frame
                if let Some(ref mut rec) = recorder {
                    let _ = rec.record_frame(&raw_frame, None);
                }
                
                // Store in ring buffer (keep last 1000 frames)
                let mut frames = state.last_frames.write().await;
                frames.push((chrono::Utc::now(), raw_frame.clone()));
                if frames.len() > 1000 {
                    frames.remove(0);
                }
            }
            WsEvent::InstrumentSnapshot(instruments) => {
                info!("Received instrument snapshot with {} pairs", instruments.len());
                for (symbol, info) in instruments {
                    state.instruments.insert(symbol.clone(), info);
                }
            }
            WsEvent::BookSnapshot {
                symbol,
                bids,
                asks,
                checksum,
            } => {
                // Initialize orderbook
                let asks_len = asks.len();
                let bids_len = bids.len();
                let mut book = Orderbook::new();
                book.apply_snapshot(bids.clone(), asks.clone());
                let depth = state.get_depth(&symbol) as usize;
                book.truncate(depth);
                
                // Verify checksum if available
                if let Some(expected_checksum) = checksum {
                    if let Some(instrument) = state.instruments.get(&symbol) {
                        let is_valid = verify_checksum(
                            &book,
                            expected_checksum,
                            instrument.price_precision,
                            instrument.qty_precision,
                        );
                        
                        let mut health = state.health.entry(symbol.clone()).or_insert_with(|| {
                            blackbox_core::health::SymbolHealth::new(symbol.clone())
                        });
                        health.connected = true;
                        health.record_message();
                        
                        if is_valid {
                            health.record_checksum_ok();
                            metrics::record_checksum_ok(&symbol);
                        } else {
                            health.record_checksum_fail();
                            metrics::record_checksum_fail(&symbol);
                            warn!("Checksum mismatch for {}: expected {}, computed different", symbol, expected_checksum);
                            
                            // Record incident
                            let incident = incident_manager
                                .record_incident(
                                    IncidentReason::ChecksumMismatch,
                                    Some(symbol.clone()),
                                    serde_json::json!({
                                        "expected_checksum": expected_checksum,
                                        "symbol": symbol,
                                    }),
                                )
                                .await;
                            
                            // Export incident bundle
                            let _ = export_incident_for_symbol(state, incident_manager, &incident, &symbol).await;
                        }
                    }
                }
                
                state.orderbooks.insert(symbol.clone(), book);
                metrics::update_orderbook_depth(&symbol, asks_len, bids_len);
            }
            WsEvent::BookUpdate {
                symbol,
                bids,
                asks,
                checksum,
                timestamp: _,
            } => {
                if let Some(mut book_entry) = state.orderbooks.get_mut(&symbol) {
                    // Apply updates
                    book_entry.apply_updates(bids.clone(), asks.clone());
                    
                    // Truncate to configured depth
                    let depth = state.get_depth(&symbol) as usize;
                    book_entry.truncate(depth);
                    
                    // Verify checksum if available
                    if let Some(expected_checksum) = checksum {
                        if let Some(instrument) = state.instruments.get(&symbol) {
                            let is_valid = verify_checksum(
                                &book_entry,
                                expected_checksum,
                                instrument.price_precision,
                                instrument.qty_precision,
                            );
                            
                            let mut health = state.health.entry(symbol.clone()).or_insert_with(|| {
                                blackbox_core::health::SymbolHealth::new(symbol.clone())
                            });
                            health.connected = true;
                            health.record_message();
                            
                            if is_valid {
                                health.record_checksum_ok();
                                metrics::record_checksum_ok(&symbol);
                            } else {
                                health.record_checksum_fail();
                                metrics::record_checksum_fail(&symbol);
                                warn!("Checksum mismatch for {}: expected {}", symbol, expected_checksum);
                                
                                // Record incident
                                let incident = incident_manager
                                    .record_incident(
                                        IncidentReason::ChecksumMismatch,
                                        Some(symbol.clone()),
                                        serde_json::json!({
                                            "expected_checksum": expected_checksum,
                                            "symbol": symbol,
                                        }),
                                    )
                                    .await;
                                
                                // Export incident bundle
                                let _ = export_incident_for_symbol(state, incident_manager, &incident, &symbol).await;
                            }
                        }
                    }
                    
                    let (asks_depth, bids_depth) = book_entry.depth();
                    metrics::update_orderbook_depth(&symbol, asks_depth, bids_depth);
                }
            }
            WsEvent::Error(err) => {
                error!("WebSocket error: {}", err);
            }
            WsEvent::RateLimitExceeded => {
                warn!("Rate limit exceeded, entering cooldown");
                metrics::record_reconnect();
                
                // Record incident
                let _ = incident_manager
                    .record_incident(
                        IncidentReason::RateLimit,
                        None,
                        serde_json::json!({}),
                    )
                    .await;
                
                sleep(Duration::from_secs(60)).await; // Cooldown period
            }
        }
    }
}

async fn export_incident_for_symbol(
    state: &AppState,
    incident_manager: &Arc<IncidentManager>,
    incident: &blackbox_core::incident::Incident,
    symbol: &str,
) -> anyhow::Result<()> {
    let config = serde_json::json!({
        "symbol": symbol,
        "depth": state.get_depth(symbol),
    });
    
    let overall = state.overall_health();
    let health = serde_json::to_value(&overall)?;
    
    let instrument = state.instruments.get(symbol).map(|e| e.value().clone());
    
    let book_top = state.orderbooks.get(symbol).map(|book| {
        serde_json::json!({
            "best_bid": book.best_bid().map(|(p, q)| (p.to_string(), q.to_string())),
            "best_ask": book.best_ask().map(|(p, q)| (p.to_string(), q.to_string())),
        })
    });
    
    let frames = state.last_frames.read().await;
    let frames_vec: Vec<_> = frames.iter().cloned().collect();
    
    incident_manager
        .export_incident_bundle(
            incident,
            config,
            health,
            instrument.as_ref(),
            book_top,
            &frames_vec,
            incident.timestamp,
        )
        .await?;
    
    Ok(())
}

async fn replay_recording(
    input: PathBuf,
    speed: f64,
    http_addr: String,
    fault: FaultRule,
) -> anyhow::Result<()> {
    info!("Replaying recording from {:?} at {}x speed", input, speed);

    let mode = if speed == 1.0 {
        ReplayMode::Realtime
    } else if speed > 0.0 {
        ReplayMode::Speed(speed)
    } else {
        ReplayMode::AsFast
    };

    let config = ReplayConfig { mode, fault };
    let mut replayer = Replayer::new(input.clone(), config)?;
    replayer.start();

    // Create shared state
    let state = AppState::new();
    
    // Create incident manager
    let incidents_dir = PathBuf::from("./incidents");
    let incident_manager = Arc::new(IncidentManager::new(incidents_dir)?);

    // Spawn processor for replay (simplified - full processing would require more work)
    let _state_clone = state.clone();
    let _incident_manager_clone = incident_manager.clone();
    let processor_handle = tokio::spawn(async move {
        use blackbox_ws::parser::parse_frame;
        
        // Process replayed frames (simplified - would need full processing logic)
        while !replayer.is_done() {
            if let Some(frame) = replayer.next_frame() {
                // Parse frame similar to live processing
                match parse_frame(&frame) {
                    Ok(_parsed) => {
                        // TODO: Process parsed frame through same pipeline as live
                        // For now, just log
                    }
                    Err(e) => {
                        warn!("Failed to parse replayed frame: {}", e);
                    }
                }
            } else {
                // Need to wait for next frame timing
                sleep(Duration::from_millis(10)).await;
            }
        }
        info!("Replay completed");
    });

    // Start HTTP server
    let app = router(state.clone(), incident_manager.clone())
        .route("/", get(|| async { Html(static_ui::UI_HTML) }));
    
    let server_handle = tokio::spawn(async move {
        let listener = tokio::net::TcpListener::bind(&http_addr).await.unwrap();
        info!("HTTP server listening on http://{}", http_addr);
        axum::serve(listener, app).await.unwrap();
    });

    tokio::select! {
        _ = processor_handle => {
            info!("Replay completed");
        }
        _ = server_handle => {}
    }

    Ok(())
}

async fn run_tui_mode(
    symbols: Vec<String>,
    depth: u32,
    http_addr: String,
    ping_interval_str: String,
    record_path: Option<PathBuf>,
    replay_path: Option<PathBuf>,
    speed: f64,
    fault: String,
    once_at: Option<usize>,
    mock: bool,
) -> anyhow::Result<()> {
    info!("Starting Kraken Blackbox TUI - Integrity Tab");
    info!("Symbols: {:?}, Depth: {}, Mock: {}", symbols, depth, mock);

    let mode = if replay_path.is_some() {
        "REPLAY"
    } else if mock {
        "MOCK"
    } else {
        "LIVE"
    };

    // Build fault status string
    let fault_status = if fault == "none" || once_at.is_none() {
        "OFF".to_string()
    } else {
        format!("{}@{}", fault, once_at.unwrap())
    };

    // Create shared state
    let state = AppState::new();
    
    // Set depth for all symbols
    for symbol in &symbols {
        state.set_depth(symbol, depth);
    }

    // Create incident manager
    let incidents_dir = PathBuf::from("./incidents");
    let incident_manager = Arc::new(IncidentManager::new(incidents_dir)?);

    if mock {
        // Mock mode: spawn fake data generator
        let state_clone = state.clone();
        let symbols_clone = symbols.clone();
        tokio::spawn(async move {
            mock_data_generator(state_clone, symbols_clone).await;
        });
    } else if let Some(replay_file) = replay_path {
        // Replay mode
        let fault_rule = build_fault_rule_from_str(&fault, once_at);
        let mode = if speed == 1.0 {
            ReplayMode::Realtime
        } else if speed > 0.0 {
            ReplayMode::Speed(speed)
        } else {
            ReplayMode::AsFast
        };
        let config = ReplayConfig { mode, fault: fault_rule };
        
        let state_clone = state.clone();
        tokio::spawn(async move {
            replay_recording_internal(replay_file, config, state_clone).await;
        });
    } else {
        // Live mode
        let ping_interval = parse_duration(&ping_interval_str)
            .context("Invalid ping interval format")?;
        
        let recorder = if let Some(path) = record_path.clone() {
            Some(Recorder::new(path)?)
        } else {
            None
        };
        
        let (ws_tx, mut ws_rx) = mpsc::unbounded_channel();
        let client = WsClient::new(symbols.clone(), depth, ping_interval, ws_tx);
        let client_handle = tokio::spawn(async move {
            if let Err(e) = client.run().await {
                error!("WebSocket client error: {}", e);
            }
        });
        
        let state_clone = state.clone();
        let incident_manager_clone = incident_manager.clone();
        let mut recorder_mut = recorder;
        let processor_handle = tokio::spawn(async move {
            process_ws_events_with_logging(&state_clone, &incident_manager_clone, &mut ws_rx, recorder_mut.as_mut()).await;
        });
        
        tokio::spawn(async move {
            tokio::select! {
                _ = client_handle => {}
                _ = processor_handle => {}
            }
        });
    }

    // Create TUI app
    let recording_path_str = record_path.as_ref().and_then(|p| p.to_str().map(|s| s.to_string()));
    let tui_app = tui::TuiApp::new(state, recording_path_str);
    
    // Run TUI (blocks until quit)
    tui::run_tui_with_manager(tui_app, mode.to_string(), fault_status, Some(incident_manager)).await?;

    Ok(())
}

async fn mock_data_generator(state: AppState, symbols: Vec<String>) {
    use crate::state::UiEvent;
    use blackbox_core::orderbook::Orderbook;
    use blackbox_core::types::InstrumentInfo;
    use rust_decimal::Decimal;
    
    // Base prices for different symbols
    let base_prices: std::collections::HashMap<String, Decimal> = symbols.iter()
        .map(|s| {
            let price = match s.as_str() {
                "BTC/USD" => Decimal::from(95000_00) / Decimal::from(100),
                "ETH/USD" => Decimal::from(3000_00) / Decimal::from(100),
                "SOL/USD" => Decimal::from(200_00) / Decimal::from(100),
                _ => Decimal::from(100_00) / Decimal::from(100),
            };
            (s.clone(), price)
        })
        .collect();
    
    // Initialize health entries, orderbooks, and instruments for all symbols
    for symbol in &symbols {
        state.health.insert(symbol.clone(), blackbox_core::health::SymbolHealth::new(symbol.clone()));
        
        // Create initial orderbook with fake data
        let mut book = Orderbook::new();
        let base_price = base_prices.get(symbol).copied().unwrap_or(Decimal::from(100_00) / Decimal::from(100));
        
        // Generate initial bids and asks
        let mut bids = Vec::new();
        let mut asks = Vec::new();
        
        for i in 0..10 {
            let bid_price = base_price - Decimal::from(i) * Decimal::from(10_00) / Decimal::from(100);
            let ask_price = base_price + Decimal::from(i + 1) * Decimal::from(10_00) / Decimal::from(100);
            let bid_qty = Decimal::from(10 - i) * Decimal::from(1_000_000) / Decimal::from(10_000_000);
            let ask_qty = Decimal::from(i + 1) * Decimal::from(1_000_000) / Decimal::from(10_000_000);
            bids.push((bid_price, bid_qty));
            asks.push((ask_price, ask_qty));
        }
        
        book.apply_snapshot(bids, asks);
        state.orderbooks.insert(symbol.clone(), book);
        
        // Create instrument info
        let instrument = InstrumentInfo {
            symbol: symbol.clone(),
            price_precision: 2,
            qty_precision: 6,
            price_increment: Decimal::from(1) / Decimal::from(100), // 0.01
            qty_increment: Decimal::from(1) / Decimal::from(1_000_000), // 0.000001
            status: "online".to_string(),
        };
        state.instruments.insert(symbol.clone(), instrument);
    }
    
    state.push_event(UiEvent::Connected).await;
    state.push_event(UiEvent::SubscribedInstrument).await;
    state.push_event(UiEvent::SubscribedBook).await;
    
    let mut interval = tokio::time::interval(Duration::from_millis(100));
    let mut counter = 0u64;
    
    loop {
        interval.tick().await;
        counter += 1;
        
        // Update fake health metrics and orderbooks for all symbols
        for symbol in &symbols {
            if let Some(mut health) = state.health.get_mut(symbol) {
                health.connected = true;
                health.record_message();
                
                // Update orderbook with small price movements
                if let Some(mut book_entry) = state.orderbooks.get_mut(symbol) {
                    let book = book_entry.value_mut();
                    let base_price = base_prices.get(symbol).copied().unwrap_or(Decimal::from(100_00) / Decimal::from(100));
                    
                    // Add some randomness to prices (simulate market movement)
                    let wiggle_val = (counter % 20) as i64 - 10;
                    let price_wiggle = Decimal::from(wiggle_val) * Decimal::from(1_000_000) / Decimal::from(10_000_000);
                    let current_base = base_price + price_wiggle;
                    
                    // Update a random level
                    let level_to_update = (counter as usize + symbol.len()) % 10;
                    
                    let bid_price = current_base - Decimal::from(level_to_update) * Decimal::from(10_00) / Decimal::from(100);
                    let ask_price = current_base + Decimal::from(level_to_update + 1) * Decimal::from(10_00) / Decimal::from(100);
                    
                    // Sometimes remove a level, sometimes add/update
                    if counter % 50 == 0 && level_to_update < 5 {
                        // Remove a level occasionally
                        book.apply_updates(
                            vec![(bid_price, Decimal::ZERO)],
                            vec![],
                        );
                    } else {
                        // Update quantities
                        let qty = Decimal::from(10 - level_to_update % 10) * Decimal::from(1_000_000) / Decimal::from(10_000_000);
                        book.apply_updates(
                            vec![(bid_price, qty)],
                            vec![(ask_price, qty)],
                        );
                    }
                    
                    // Truncate to depth
                    book.truncate(10);
                }
                
                if counter % 1000 == 0 {
                    // Occasional checksum failure for demo
                    health.record_checksum_fail();
                    state.push_event(UiEvent::ChecksumMismatch { symbol: symbol.clone() }).await;
                } else {
                    health.record_checksum_ok();
                    state.push_event(UiEvent::ChecksumOk { symbol: symbol.clone() }).await;
                }
                health.update_msg_rate(10.0);
            }
        }
    }
}

fn build_fault_rule_from_str(fault: &str, once_at: Option<usize>) -> FaultRule {
    if fault == "none" || once_at.is_none() {
        return FaultRule::None;
    }
    
    let index = once_at.unwrap();
    match fault {
        "drop" => FaultRule::OnceAt { index, fault: FaultType::Drop },
        "reorder" => FaultRule::OnceAt { index, fault: FaultType::Reorder },
        "mutate_qty" => FaultRule::OnceAt { index, fault: FaultType::MutateQty { delta_ticks: 1 } },
        _ => FaultRule::None,
    }
}

async fn replay_recording_internal(
    input: PathBuf,
    config: ReplayConfig,
    state: AppState,
) -> anyhow::Result<()> {
    use crate::state::UiEvent;
    use blackbox_core::replayer::Replayer;
    use blackbox_ws::parser::parse_frame;
    use blackbox_ws::client::WsEvent;
    use tokio::sync::mpsc;
    
    info!("Starting replay from {}", input.display());
    state.push_event(UiEvent::RecordStarted { path: input.to_string_lossy().to_string() }).await;
    state.push_event(UiEvent::Connected).await;
    
    // Create replayer
    let mut replayer = Replayer::new(input, config.clone())?;
    replayer.start();
    
    // Create a channel to feed events to the processor
    let (ws_tx, mut ws_rx) = mpsc::unbounded_channel();
    
    // Spawn processor to handle events (same as live mode)
    let state_clone = state.clone();
    let incident_manager = Arc::new(IncidentManager::new(std::path::PathBuf::from("./incidents"))?);
    let incident_manager_clone = incident_manager.clone();
    let processor_handle = tokio::spawn(async move {
        process_ws_events_with_logging(&state_clone, &incident_manager_clone, &mut ws_rx, None).await;
    });
    
    // Send Connected event
    let _ = ws_tx.send(WsEvent::Connected);
    
    loop {
        // Get next frame from replayer
        let frame_data = match replayer.next_frame() {
            Some(frame) => frame,
            None => {
                info!("Replay completed");
                state.push_event(UiEvent::RecordStopped).await;
                break;
            }
        };
        
        // Send Frame event
        let _ = ws_tx.send(WsEvent::Frame(frame_data.clone()));
        
        // Parse frame and convert to WsEvent (same logic as WsClient)
        if let Ok(parsed) = parse_frame(&frame_data) {
            match parsed {
                blackbox_ws::parser::WsFrame::Instrument(msg) => {
                    if msg.msg_type == "snapshot" {
                        use blackbox_core::precision::parse_decimal;
                        use std::collections::HashMap;
                        let mut instruments = HashMap::new();
                        for pair in msg.data.pairs {
                            match (parse_decimal(&pair.price_increment), parse_decimal(&pair.qty_increment)) {
                                (Ok(price_inc), Ok(qty_inc)) => {
                                    let info = blackbox_core::types::InstrumentInfo {
                                        symbol: pair.symbol.clone(),
                                        price_precision: pair.price_precision,
                                        qty_precision: pair.qty_precision,
                                        price_increment: price_inc,
                                        qty_increment: qty_inc,
                                        status: pair.status,
                                    };
                                    instruments.insert(pair.symbol, info);
                                }
                                _ => continue,
                            }
                        }
                        let _ = ws_tx.send(WsEvent::InstrumentSnapshot(instruments));
                    }
                }
                blackbox_ws::parser::WsFrame::Book(msg) => {
                    for data in msg.data {
                        use blackbox_core::precision::parse_decimal;
                        
                        let mut bids = Vec::new();
                        let mut asks = Vec::new();
                        
                        if let Some(bid_levels) = data.bids {
                            for level in bid_levels {
                                let price_str = match &level.price {
                                    serde_json::Value::Number(n) => n.to_string(),
                                    serde_json::Value::String(s) => s.clone(),
                                    _ => continue,
                                };
                                let qty_str = match &level.qty {
                                    serde_json::Value::Number(n) => n.to_string(),
                                    serde_json::Value::String(s) => s.clone(),
                                    _ => continue,
                                };
                                match (parse_decimal(&price_str), parse_decimal(&qty_str)) {
                                    (Ok(price), Ok(qty)) => bids.push((price, qty)),
                                    _ => continue,
                                }
                            }
                        }
                        
                        if let Some(ask_levels) = data.asks {
                            for level in ask_levels {
                                let price_str = match &level.price {
                                    serde_json::Value::Number(n) => n.to_string(),
                                    serde_json::Value::String(s) => s.clone(),
                                    _ => continue,
                                };
                                let qty_str = match &level.qty {
                                    serde_json::Value::Number(n) => n.to_string(),
                                    serde_json::Value::String(s) => s.clone(),
                                    _ => continue,
                                };
                                match (parse_decimal(&price_str), parse_decimal(&qty_str)) {
                                    (Ok(price), Ok(qty)) => asks.push((price, qty)),
                                    _ => continue,
                                }
                            }
                        }
                        
                        if msg.msg_type == "snapshot" {
                            let _ = ws_tx.send(WsEvent::BookSnapshot {
                                symbol: data.symbol,
                                bids,
                                asks,
                                checksum: data.checksum,
                            });
                        } else {
                            let _ = ws_tx.send(WsEvent::BookUpdate {
                                symbol: data.symbol,
                                bids,
                                asks,
                                checksum: data.checksum,
                                timestamp: data.timestamp,
                            });
                        }
                    }
                }
                _ => {}
            }
        }
        
        // Small delay for UI responsiveness
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
    }
    
    // Wait for processor to finish
    drop(ws_tx);
    let _ = processor_handle.await;
    
    Ok(())
}

async fn process_ws_events_with_logging(
                        
                        // Create instrument info
                        let instrument = blackbox_core::types::InstrumentInfo {
                            symbol: pair.symbol.clone(),
                            price_precision: pair.price_precision,
                            qty_precision: pair.qty_precision,
                            price_increment: pair.price_increment.parse::<rust_decimal::Decimal>()
                                .unwrap_or(rust_decimal::Decimal::from(1) / rust_decimal::Decimal::from(100)),
                            qty_increment: pair.qty_increment.parse::<rust_decimal::Decimal>()
                                .unwrap_or(rust_decimal::Decimal::from(1) / rust_decimal::Decimal::from(1_000_000)),
                            status: pair.status.clone(),
                        };
                        state.instruments.insert(pair.symbol.clone(), instrument);
                        
                        // Initialize health entry
                        if !state.health.contains_key(&pair.symbol) {
                            state.health.insert(pair.symbol.clone(), SymbolHealth::new(pair.symbol.clone()));
                        }
                        if let Some(mut health) = state.health.get_mut(&pair.symbol) {
                            health.connected = true;
                            health.last_msg_ts = Some(now);
                        }
                        
                        // Initialize frame buffer
                        state.get_or_create_frame_buffer(&pair.symbol);
                    }
                    state.push_event(UiEvent::SubscribedInstrument).await;
                }
                blackbox_ws::parser::WsFrame::BookSnapshot { symbol, bids, asks, checksum } => {
                    // Initialize orderbook if needed
                    if !state.orderbooks.contains_key(&symbol) {
                        let mut book = Orderbook::new();
                        book.apply_snapshot(
                            bids.iter().map(|(p, q)| (p.parse().unwrap_or_default(), q.parse().unwrap_or_default())).collect(),
                            asks.iter().map(|(p, q)| (p.parse().unwrap_or_default(), q.parse().unwrap_or_default())).collect(),
                        );
                        if let Some(depth) = state.depths.get(&symbol) {
                            book.truncate(*depth.value() as usize);
                        }
                        state.orderbooks.insert(symbol.clone(), book);
                    }
                    
                    // Store frame in per-symbol buffer
                    let buffer = state.get_or_create_frame_buffer(&symbol);
                    {
                        let mut buf = buffer.write().await;
                        buf.push_back(frame_data.clone());
                        if buf.len() > 2000 {
                            buf.pop_front();
                        }
                    }
                    
                    state.push_event(UiEvent::SubscribedBook).await;
                }
                blackbox_ws::parser::WsFrame::BookUpdate { symbol, bids, asks, checksum, timestamp } => {
                    // Process book update (same as live mode)
                    if let Some(mut book_entry) = state.orderbooks.get_mut(&symbol) {
                        let book = book_entry.value_mut();
                        
                        let bid_updates: Vec<_> = bids.iter()
                            .filter_map(|(p, q)| {
                                let price = p.parse::<rust_decimal::Decimal>().ok()?;
                                let qty = q.parse::<rust_decimal::Decimal>().ok()?;
                                Some((price, qty))
                            })
                            .collect();
                        
                        let ask_updates: Vec<_> = asks.iter()
                            .filter_map(|(p, q)| {
                                let price = p.parse::<rust_decimal::Decimal>().ok()?;
                                let qty = q.parse::<rust_decimal::Decimal>().ok()?;
                                Some((price, qty))
                            })
                            .collect();
                        
                        book.apply_updates(bid_updates, ask_updates);
                        
                        if let Some(depth) = state.depths.get(&symbol) {
                            book.truncate(*depth.value() as usize);
                        }
                        
                        // Verify checksum
                        if let Some(expected_checksum) = checksum {
                            if let Some(instrument) = state.instruments.get(&symbol) {
                                let start = std::time::Instant::now();
                                let is_valid = blackbox_core::checksum::verify_checksum(
                                    book,
                                    expected_checksum,
                                    instrument.price_precision,
                                    instrument.qty_precision,
                                );
                                let latency = start.elapsed().as_millis();
                                
                                // Update health
                                if let Some(mut health) = state.health.get_mut(&symbol) {
                                    health.record_message();
                                    health.last_msg_ts = Some(now);
                                    
                                    if is_valid {
                                        health.record_checksum_ok();
                                        health.consecutive_fails = 0;
                                        state.push_event(UiEvent::ChecksumOk { symbol: symbol.clone() }).await;
                                    } else {
                                        health.record_checksum_fail();
                                        health.consecutive_fails += 1;
                                        health.last_checksum_mismatch = Some(now);
                                        state.push_event(UiEvent::ChecksumMismatch { symbol: symbol.clone() }).await;
                                        
                                        // Create incident
                                        let incident = incident_manager.record_incident(
                                            blackbox_core::incident::IncidentReason::ChecksumMismatch,
                                            Some(symbol.clone()),
                                            serde_json::json!({}),
                                        ).await;
                                        
                                        let incident_meta = IncidentMeta {
                                            id: incident.id,
                                            symbol: Some(symbol.clone()),
                                            reason: "ChecksumMismatch".to_string(),
                                            timestamp: incident.timestamp,
                                            zip_path: None,
                                            frames_path: None,
                                            frame_count: None,
                                        };
                                        state.set_last_incident(incident_meta).await;
                                        state.push_event(UiEvent::IncidentCaptured { 
                                            id: incident.id, 
                                            reason: "ChecksumMismatch".to_string() 
                                        }).await;
                                    }
                                    health.update_msg_rate(10.0);
                                }
                                
                                // Update integrity proof
                                update_integrity_proof(&state, &symbol, expected_checksum, is_valid, latency).await;
                            }
                        }
                        
                        // Store frame
                        let buffer = state.get_or_create_frame_buffer(&symbol);
                        {
                            let mut buf = buffer.write().await;
                            buf.push_back(frame_data.clone());
                            if buf.len() > 2000 {
                                buf.pop_front();
                            }
                        }
                    }
                }
                _ => {}
            }
        }
        
        // Small delay for UI responsiveness
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
    }
    
    Ok(())
}

async fn process_ws_events_with_logging(
                frames.push((chrono::Utc::now(), raw_frame.clone()));
                if frames.len() > 1000 {
                    frames.remove(0);
                }
                
                // Also store in per-symbol buffers if we can extract symbol from frame
                // This is best-effort - we'll parse JSON to find symbol
                if let Ok(json) = serde_json::from_str::<serde_json::Value>(&raw_frame) {
                    if let Some(symbol) = json.get("data").and_then(|d| d.get("symbol")).and_then(|s| s.as_str()) {
                        let frame_buffer = state.get_or_create_frame_buffer(symbol);
                        let mut buf = frame_buffer.write().await;
                        buf.push_back(raw_frame.clone());
                        while buf.len() > 2000 {
                            buf.pop_front();
                        }
                    }
                }
            }
            WsEvent::InstrumentSnapshot(instruments) => {
                info!("Received instrument snapshot with {} pairs", instruments.len());
                state.push_event(UiEvent::SubscribedInstrument).await;
                for (symbol, info) in instruments {
                    state.instruments.insert(symbol.clone(), info);
                }
            }
            WsEvent::BookSnapshot {
                symbol,
                bids,
                asks,
                checksum,
            } => {
                state.push_event(UiEvent::SubscribedBook).await;
                let mut book = Orderbook::new();
                book.apply_snapshot(bids, asks);
                let depth = state.get_depth(&symbol) as usize;
                book.truncate(depth);
                
                if let Some(expected_checksum) = checksum {
                    if let Some(instrument) = state.instruments.get(&symbol) {
                        // Update integrity proof
                        let mut proof = state.integrity_proofs
                            .entry(symbol.clone())
                            .or_insert_with(|| IntegrityProof::new());
                        
                        let is_valid = update_integrity_proof(
                            &mut proof,
                            &book,
                            expected_checksum,
                            instrument.price_precision,
                            instrument.qty_precision,
                        );
                        
                        let mut health = state.health.entry(symbol.clone()).or_insert_with(|| {
                            blackbox_core::health::SymbolHealth::new(symbol.clone())
                        });
                        health.connected = true;
                        health.record_message();
                        
                        if is_valid {
                            health.record_checksum_ok();
                            state.push_event(UiEvent::ChecksumOk { symbol: symbol.clone() }).await;
                        } else {
                            health.record_checksum_fail();
                            state.push_event(UiEvent::ChecksumMismatch { symbol: symbol.clone() }).await;
                            
                            let incident = incident_manager
                                .record_incident(
                                    IncidentReason::ChecksumMismatch,
                                    Some(symbol.clone()),
                                    serde_json::json!({"expected_checksum": expected_checksum}),
                                )
                                .await;
                            
                            // Store frames for this symbol
                            let frame_buffer = state.get_or_create_frame_buffer(&symbol);
                            let frames: Vec<String> = frame_buffer.read().await.iter().cloned().collect();
                            let frames_count = frames.len();
                            
                            // Create incident meta
                            let incident_meta = IncidentMeta::new(
                                incident.id.clone(),
                                symbol.clone(),
                                format!("{:?}", incident.reason),
                            );
                            
                            state.set_last_incident(incident_meta).await;
                            
                            state.push_event(UiEvent::IncidentCaptured {
                                id: incident.id,
                                reason: format!("{:?}", incident.reason),
                            }).await;
                        }
                    }
                }
                
                state.orderbooks.insert(symbol.clone(), book);
            }
            WsEvent::BookUpdate {
                symbol,
                mut bids,
                mut asks,
                checksum,
                timestamp: _,
            } => {
                // Check for fault injection
                if let Some((target_symbol, fault_type)) = state.fault_injector.consume() {
                    if target_symbol == symbol {
                        match fault_type {
                            crate::integrity::fault::FaultType::MutateQty => {
                                // Mutate first ask qty by smallest increment
                                if let Some(first_ask) = asks.first_mut() {
                                    if let Ok(mut qty) = first_ask.1.to_string().parse::<rust_decimal::Decimal>() {
                                        // Add smallest increment
                                        if let Some(instrument) = state.instruments.get(&symbol) {
                                            qty = qty + instrument.qty_increment;
                                            first_ask.1 = qty;
                                        }
                                    }
                                }
                            }
                            crate::integrity::fault::FaultType::DropUpdate => {
                                // Drop this update - return early
                                continue;
                            }
                        }
                    }
                }
                
                if let Some(mut book_entry) = state.orderbooks.get_mut(&symbol) {
                    book_entry.apply_updates(bids.clone(), asks.clone());
                    let depth = state.get_depth(&symbol) as usize;
                    book_entry.truncate(depth);
                    
                    if let Some(expected_checksum) = checksum {
                        if let Some(instrument) = state.instruments.get(&symbol) {
                            // Update integrity proof
                            let mut proof = state.integrity_proofs
                                .entry(symbol.clone())
                                .or_insert_with(|| IntegrityProof::new());
                            
                            let is_valid = update_integrity_proof(
                                &mut proof,
                                &book_entry,
                                expected_checksum,
                                instrument.price_precision,
                                instrument.qty_precision,
                            );
                            
                            let mut health = state.health.entry(symbol.clone()).or_insert_with(|| {
                                blackbox_core::health::SymbolHealth::new(symbol.clone())
                            });
                            health.connected = true;
                            health.record_message();
                            
                            if is_valid {
                                health.record_checksum_ok();
                                state.push_event(UiEvent::ChecksumOk { symbol: symbol.clone() }).await;
                            } else {
                                health.record_checksum_fail();
                                state.push_event(UiEvent::ChecksumMismatch { symbol: symbol.clone() }).await;
                                
                                let incident = incident_manager
                                    .record_incident(
                                        IncidentReason::ChecksumMismatch,
                                        Some(symbol.clone()),
                                        serde_json::json!({"expected_checksum": expected_checksum}),
                                    )
                                    .await;
                                
                                // Store frames for this symbol
                                let frame_buffer = state.get_or_create_frame_buffer(&symbol);
                                let _frames: Vec<String> = frame_buffer.read().await.iter().cloned().collect();
                                
                                // Create incident meta
                                let incident_meta = IncidentMeta::new(
                                    incident.id.clone(),
                                    symbol.clone(),
                                    format!("{:?}", incident.reason),
                                );
                                
                                state.set_last_incident(incident_meta).await;
                                
                                state.push_event(UiEvent::IncidentCaptured {
                                    id: incident.id,
                                    reason: format!("{:?}", incident.reason),
                                }).await;
                            }
                        }
                    }
                    
                    let (asks_depth, bids_depth) = book_entry.depth();
                    metrics::update_orderbook_depth(&symbol, asks_depth, bids_depth);
                }
            }
            WsEvent::Error(err) => {
                error!("WebSocket error: {}", err);
            }
            WsEvent::RateLimitExceeded => {
                warn!("Rate limit exceeded");
                state.push_event(UiEvent::Disconnected).await;
                sleep(Duration::from_secs(60)).await;
            }
        }
    }
}

async fn replay_incident_bundle(
    bundle_path: PathBuf,
    speed: f64,
    http_addr: String,
) -> anyhow::Result<()> {
    use std::fs::File;
    use std::io::Read;
    use zip::ZipArchive;
    
    info!("Replaying incident bundle from {:?} at {}x speed", bundle_path, speed);
    
    // Extract frames.ndjson from bundle
    let file = File::open(&bundle_path)?;
    let mut archive = ZipArchive::new(file)?;
    
    let mut frames_file = archive.by_name("frames.ndjson")
        .context("frames.ndjson not found in bundle")?;
    
    let mut frames_content = String::new();
    frames_file.read_to_string(&mut frames_content)?;
    
    // Write frames to temporary file for replayer
    let temp_frames = std::env::temp_dir().join(format!("replay_{}.ndjson", chrono::Utc::now().timestamp()));
    std::fs::write(&temp_frames, frames_content)?;
    
    // Replay with no faults
    let mode = if speed == 1.0 {
        ReplayMode::Realtime
    } else if speed > 0.0 {
        ReplayMode::Speed(speed)
    } else {
        ReplayMode::AsFast
    };
    
    let config = ReplayConfig {
        mode,
        fault: FaultRule::None,
    };
    
    let mut replayer = Replayer::new(temp_frames.clone(), config)?;
    replayer.start();
    
    // Create shared state
    let state = AppState::new();
    
    // Spawn processor for replay (simplified - would need full processing logic)
    let processor_handle = tokio::spawn(async move {
        use blackbox_ws::parser::parse_frame;
        
        while !replayer.is_done() {
            if let Some(frame) = replayer.next_frame() {
                match parse_frame(&frame) {
                    Ok(_parsed) => {
                        // Process frame (would need full processing logic here)
                    }
                    Err(e) => {
                        warn!("Failed to parse replayed frame: {}", e);
                    }
                }
            } else {
                sleep(Duration::from_millis(10)).await;
            }
        }
        info!("Replay completed");
    });
    
    // Start HTTP server
    let incidents_dir = PathBuf::from("./incidents");
    let incident_manager = Arc::new(IncidentManager::new(incidents_dir)?);
    let app = router(state.clone(), incident_manager.clone())
        .route("/", get(|| async { Html(static_ui::UI_HTML) }));
    
    let server_handle = tokio::spawn(async move {
        let listener = tokio::net::TcpListener::bind(&http_addr).await.unwrap();
        info!("HTTP server listening on http://{}", http_addr);
        axum::serve(listener, app).await.unwrap();
    });
    
    tokio::select! {
        _ = processor_handle => {
            info!("Replay completed");
        }
        _ = server_handle => {}
    }
    
    // Cleanup temp file
    let _ = std::fs::remove_file(&temp_frames);
    
    Ok(())
}

fn build_fault_rule(
    drop_every: Option<usize>,
    drop_once: Option<usize>,
    reorder_once: Option<usize>,
    mutate_once: Option<usize>,
    mutate_delta: i32,
) -> FaultRule {
    if let Some(n) = drop_every {
        return FaultRule::Every {
            n,
            fault: FaultType::Drop,
        };
    }
    if let Some(idx) = drop_once {
        return FaultRule::OnceAt {
            index: idx,
            fault: FaultType::Drop,
        };
    }
    if let Some(idx) = reorder_once {
        return FaultRule::OnceAt {
            index: idx,
            fault: FaultType::Reorder,
        };
    }
    if let Some(idx) = mutate_once {
        return FaultRule::OnceAt {
            index: idx,
            fault: FaultType::MutateQty {
                delta_ticks: mutate_delta,
            },
        };
    }
    FaultRule::None
}

fn parse_duration(s: &str) -> anyhow::Result<Duration> {
    let s = s.trim();
    if s.ends_with('s') {
        let secs: u64 = s[..s.len() - 1].parse()?;
        Ok(Duration::from_secs(secs))
    } else if s.ends_with('m') {
        let mins: u64 = s[..s.len() - 1].parse()?;
        Ok(Duration::from_secs(mins * 60))
    } else {
        // Try parsing as seconds
        let secs: u64 = s.parse()?;
        Ok(Duration::from_secs(secs))
    }
}

